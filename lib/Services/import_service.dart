import 'dart:io';
import 'dart:convert';
import 'package:csv/csv.dart';
import 'package:file_picker/file_picker.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:money_control/Models/transaction.dart';
import 'package:intl/intl.dart';

class ImportService {
  /// Pick a CSV file and return its content as a List of Lists
  static Future<List<List<dynamic>>?> pickAndParseCSV() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['csv'],
      );

      if (result != null && result.files.single.path != null) {
        File file = File(result.files.single.path!);
        final input = file.openRead();
        final fields = await input
            .transform(utf8.decoder)
            .transform(const CsvToListConverter())
            .toList();
        return fields;
      }
    } catch (e) {
      print("Error picking CSV: $e");
    }
    return null;
  }

  /// Process the raw CSV data into TransactionModel objects based on column mapping
  /// [headerMap] maps internal keys ('amount', 'date', 'note', 'category') to CSV column indices
  static List<TransactionModel> processCSVData(
    List<List<dynamic>> rawData,
    Map<String, int> headerMap,
    String currentUserId,
  ) {
    List<TransactionModel> transactions = [];

    // Skip header row (index 0)
    for (int i = 1; i < rawData.length; i++) {
      try {
        final row = rawData[i];

        // Extract values using the mapped indices
        final dateIndex = headerMap['date'];
        final amountIndex = headerMap['amount'];
        final noteIndex = headerMap['note']; // Optional
        final categoryIndex = headerMap['category']; // Optional

        if (dateIndex == null || amountIndex == null)
          continue; // Skip invalid mapping

        // 1. Parse Date
        DateTime date = DateTime.now();
        final rawDate = row[dateIndex];
        if (rawDate is String) {
          // Attempt standard formats
          date =
              DateTime.tryParse(rawDate) ??
              _tryParseCustomDate(rawDate) ??
              DateTime.now();
        }

        // 2. Parse Amount
        double amount = 0.0;
        final rawAmount = row[amountIndex];
        if (rawAmount is num) {
          amount = rawAmount.toDouble();
        } else if (rawAmount is String) {
          amount =
              double.tryParse(rawAmount.replaceAll(RegExp(r'[^0-9.-]'), '')) ??
              0.0;
        }

        // 3. Parse Note/Description
        String note = "Imported Transaction";
        if (noteIndex != null && noteIndex < row.length) {
          note = row[noteIndex].toString();
        }

        // 4. Parse Category
        String category = "Uncategorized";
        if (categoryIndex != null && categoryIndex < row.length) {
          category = row[categoryIndex].toString();
        }

        // Create Model
        final tx = TransactionModel(
          id: '', // Will be generated by Firestore on add
          senderId: currentUserId, // Assume user is sender for expense
          recipientId: 'Imported', // Placeholder
          recipientName: note, // Use description as recipient/title
          amount: amount,
          currency: 'INR', // Default to INR for now, or add currency mapping
          tax: 0,
          note: "Imported from CSV",
          category: category,
          date: date,
          status: 'success',
          createdAt: Timestamp.now(),
        );

        transactions.add(tx);
      } catch (e) {
        print("Error parsing row $i: $e");
        continue;
      }
    }
    return transactions;
  }

  static DateTime? _tryParseCustomDate(String dateStr) {
    final formats = [
      DateFormat("dd/MM/yyyy"),
      DateFormat("MM/dd/yyyy"),
      DateFormat("yyyy-MM-dd"),
      DateFormat("dd-MM-yyyy"),
    ];

    for (var format in formats) {
      try {
        return format.parse(dateStr);
      } catch (_) {}
    }
    return null;
  }

  /// Batch save transactions to Firestore
  static Future<void> saveTransactionsToFirestore(
    List<TransactionModel> transactions,
    String userId,
  ) async {
    final batch = FirebaseFirestore.instance.batch();
    final collection = FirebaseFirestore.instance
        .collection('users')
        .doc(userId)
        .collection('transactions');

    for (var tx in transactions) {
      final docRef = collection.doc(); // Auto-ID
      // Create a map but ensure ID is empty so it doesn't try to write a blank ID field if strict
      // Actually TransactionModel.toMap wants an ID? No, check model.

      // We need to adhere to the model's structure.
      // The current toMap includes 'status', 'createdAt' etc.

      batch.set(docRef, tx.toMap());
    }

    await batch.commit();
  }
}
